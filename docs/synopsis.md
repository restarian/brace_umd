## Synopsis

[![Build status](https://ci.appveyor.com/api/projects/status/8ou8s3c7ocq0972h/branch/master?svg=true)](https://ci.appveyor.com/project/restarian/brace-umd/branch/master) [![Build Status](https://travis-ci.org/restarian/brace_umd.svg?branch=master)](https://travis-ci.org/restarian/brace_umd) [![Downloads](https://img.shields.io/npm/dm/brace_umd.svg?svg=true)](https://npmjs.org/package/brace_umd)

| **The [Brace Suite]** | **[Ubuntu on Windows]**   |
|:---------------------:|:-------------------------:|
| ![Brace logo]         | ![Ubuntu on Windows logo] |         |

[Brace Suite]: https://github.com/restarian/restarian/tree/master/brace/
[Ubuntu on Windows]: https://www.microsoft.com/en-us/store/p/ubuntu/9nblggh4msv6?activetab=pivot%3aoverviewtab 

[Ubuntu on Windows logo]: https://raw.githubusercontent.com/restarian/restarian/master/doc/image/ubuntu_windows_logo.png
[Brace logo]: https://raw.githubusercontent.com/restarian/restarian/master/brace/doc/image/brace_logo_small.png

---
### Brace UMD pages
* [What the build exports](https://github.com/restarian/brace_umd/blob/master/docs/what_the_build_exports.md)
* [Using the optimizer](https://github.com/restarian/brace_umd/blob/master/docs/using_the_optimizer.md)
* [Unit testing outline](https://github.com/restarian/brace_umd/blob/master/docs/unit_testing_outline.md)
* **Synopsis**
* [Passing option data to the umd](https://github.com/restarian/brace_umd/blob/master/docs/passing_option_data_to_the_umd.md)
* [Package information](https://github.com/restarian/brace_umd/blob/master/docs/package_information.md)
* [How option handling works](https://github.com/restarian/brace_umd/blob/master/docs/how_option_handling_works.md)
* [Building the umd with other options](https://github.com/restarian/brace_umd/blob/master/docs/building_the_umd_with_other_options.md)

---

#### A unified module definition script to support Requirejs and AMDefine definitions while working seamlessly with the RequireJs optimizer and native global Objects.

**Licensed under: MIT WITH BSD-2-Clause**

**Bonuses:**
* Allows for zero dependency module creation when used with the r.js optimizer and the built in factory loader
* Provides automatic anonymous module creation for amdefine modules
* Adds only one new namespace (umd), by using a self-destructing proxy method
* Provides a way to switch between definition types without altering source code
* Allows for almost total minification of wrapped source code using almost all of the uglify-js options
* Extensible friendly design regarding other asynchronous module definitions
* Well commented, professionally engineered and thoroughly documented code
* Vast and deep unit tests on Windows 10 and Ubuntu 16

**Caveats:**
  * Requires nodejs version 5 or greater

**Brace UMD is way better than other more simple module definitions** by providing _uglify-js_ functionality and option passing. The AMD library is only loaded and used if the correlated call to it is contained within the script. E.g. The *amdefine* module is not loaded unless a call to *define* is inside of the script. Otherwise, a proxy function is supplied for the supported definitions.

**Note**: it is acceptable to use mangle and mangle properties with the UMD source and in the requirejs optimizing process. This is done by storing the build config options used and then passing them back into uglify-js via the r.js build config file (see [using with requirejs](https://github.com/restarian/brace_umd/blob/master/docs/using_the_optimizer.md), for more information.

**Below is the UMD complete umd script. The following code will work in nodejs or the browser and can use any of the supported definitions:**

```javascript
/* Generated by Brace_UMD 0.8.2 */
!function(e, i, r, t) {
    var define, requirejs, require, umd = {
        e: 'object' == typeof module && 'filename' in module && 'exports' in module,
        requirejs: r,
        define: i,
        i: 'object' == typeof t && t || {},
        r: function() {
            var e = {
                define: !this.i.auto_anonymous && this.define || this.t,
                requirejs: this.requirejs || this.o,
                require: this.requirejs || this.e && module.require || this.factory,
                factory: this.factory
            };
            this.i.force_type in e && (e.requirejs = e.require = e.define = e.factory = e[this.i.force_type]), 
            define = e.define, requirejs = e.requirejs, require = e.require;
        },
        n: !1,
        factory: function(i, r, t, o) {
            i && i.constructor === Array ? (o = t, t = r, r = i, i = '') : 'string' != typeof i && (o = r, 
            t = i, r = [ 'require' ], i = '');
            var n = [], f = umd.e && module.require || e.require, u = '';
            if (r.every(function(i) {
                return i = i.replace(/^\.[\/,\\]/, ''), n.push('require' === i && f || e[i]), 'require' === i || i in e || (u = i), 
                !u;
            }), !0 !== umd.n) {
                if (!i) return umd.n = !0, void (u ? console.log('The amd factory attempted to load the', i || 'anonymous', 'module that specified a dependency which was not defined:', u) : umd.e ? module.exports = t.apply(t.prototype, n) : t.apply(t.prototype, n));
                umd.n = i;
            }
            umd.e ? module.exports[i] = t.apply(t.prototype, n) : e[i] = t.apply(t.prototype, n);
        },
        f: [ 'config', 'nextTick', 'version', 'jsExtRegExp', 'isBrowser', 's', 'toUrl', 'undef', 'defined', 'specified', 'onError', 'createNode', 'load', 'exec' ],
        u: [ 'amd', 'require' ],
        t: function() {
            if (umd.e && !umd.define) try {
                umd.define = module.require('amdefine')(module);
                for (var e in umd.define) umd.t[e] = umd.define[e];
            } catch (e) {}
            var i = umd.define || umd.factory;
            i == umd.define && umd.i.auto_anonymous ? !0 !== umd.n && 'string' == typeof arguments[0] ? umd.n = arguments[0] : 'string' != typeof arguments[0] && (umd.n = !0) : (umd.t = i, 
            umd.r()), i.apply(i.prototype, arguments);
        },
        o: function() {
            if (umd.e) try {
                umd.requirejs = module.require('requirejs');
            } catch (e) {}
            umd.o = umd.requirejs || umd.factory, umd.r(), umd.o.apply(umd.o.prototype, arguments);
        }
    };
    for (var o in umd.u) umd.t.__defineGetter__(umd.u[o], function(e) {
        if (umd.e && !umd.define) try {
            umd.define = module.require('amdefine')(module);
            for (var i in umd.define) delete this[i], this[i] = umd.define[i];
            return umd.define[e];
        } catch (e) {}
    }.bind(null, umd.u[o]));
    if (!requirejs) for (var o in umd.f) umd.o.__defineGetter__(umd.f[o], function(e) {
        if (umd.e) try {
            return umd.requirejs = module.require('requirejs'), umd.o = umd.requirejs, umd.r(), 
            umd.requirejs[e];
        } catch (e) {
            return;
        }
    }.bind(null, umd.f[o]));
    umd.r()
// -- Add your module definitions here ----------------



// ----------------------------------------------------
umd.n.length && define([ umd.n ], function(e) {
        return e;
   });
}(this, 'function' == typeof define && define || void 0, 'function' == typeof requirejs && requirejs || void 0, {});

```
