/* Generated by Brace_UMD 0.3.1 */
!function(e, o, r, i, n) {
    n = n || {};
    var t, s, d, f = {
        requirejs: i,
        define: r,
        e: o && o.o && o || void 0,
        i: o && o.o || e,
        n: "requirejs,define,require,factory,",
        force_type: n.force_type,
        r: [ "config", "nextTick", "version", "jsExtRegExp", "isBrowser", "s", "toUrl", "undef", "defined", "specified", "onError", "createNode", "load", "exec" ],
        t: [ "amd", "require" ],
        s: function() {
            if (f.e && !f.define) try {
                f.define = f.e.require("amdefine")(f.e);
                for (var e in f.define) f.s[e] = f.define[e];
            } catch (e) {
                console.log(e.message);
            }
            var o = f.define || f.factory;
            o == f.define ? console.log("Using proxied amdefine definition.") : console.log("Using factory proxied from amdefine call."), 
            o.apply(o.prototype, arguments);
        },
        d: function() {
            if (f.e && !f.requirejs) try {
                f.requirejs = f.e.require("requirejs");
                for (var e in f.requirejs) f.d[e] = f.requirejs[e];
            } catch (e) {
                console.log(e.message);
            }
            console.log("Using proxied requirejs method.");
            var o = f.requirejs || f.factory;
            o.apply(o.prototype, arguments);
        }
    };
    for (var c in f.t) f.s.__defineGetter__(f.t[c], function(e) {
        if (f.e && !f.define) try {
            f.define = f.e.require("amdefine")(f.e);
            for (var o in f.define) delete this[o], this[o] = f.define[o];
            return console.log("Using proxied amdefine method."), f.define[e];
        } catch (e) {
            return console.log(e.message);
        }
    }.bind(null, f.t[c]));
    for (var c in f.r) f.d.__defineGetter__(f.r[c], function(e) {
        if (f.e && !f.requirejs) try {
            f.requirejs = f.e.require("requirejs");
            for (var o in f.requirejs) delete this[o], this[o] = f.requirejs[o];
            return console.log("Using proxied requirejs method."), f.requirejs[o];
        } catch (e) {
            return console.log(e.message);
        }
    }.bind(null, f.r[c]));
    f.factory = f.i && function(e, o, r, i) {
        if (e && e.constructor === Array && this.e) {
            var n = e, t = dependency;
            i = i, r = r, dependency = n, e = this.e.f || "";
        }
        "string" != typeof e ? console.log("The factory Object is being used but the module does not supply an id parameter. Skipping loading of the module.") : o.every(function(o) {
            return o in this.i || !!console.log("The dependency", o, "is not loaded into the factory. Skipping loading of the module", e);
        }, this) && (this.i[e] = r.apply(r.prototype, o.map(function(e, o) {
            return this.i[e];
        }, this)));
    }.bind(f), f.force_type && (new RegExp(f.force_type + ",+").test(f.n) ? f[f.force_type] ? (console.log("Forcing use of the definition type", f.force_type), 
    f.requirejs = f.require = f.define = f.factory = f[f.force_type]) : console.log("The forced type", f.force_type, "is not available.") : console.log("The forced type", f.force_type, "specified as an option is not supported by Brace UMD. Supported types are", f.n.substr(0, f.n.length - 2))), 
    s = f.define || f.s, d = f.requirejs || f.d, t = f.e && f.e.require || d;
    s("second_module", [], function() {
        var e = "second_module";
        console.log(e + " has initialized.");
        var o = {};
        o.id = e;
        return o;
    });
    s("base_module", [ "second_module" ], function(e) {
        var o = "base_module";
        console.log(o + " has initialized.");
        var r = {};
        r.id = o;
        r[e.id] = e;
        return r;
    });
}(this, "object" == typeof module && module || void 0, "function" == typeof define && define || void 0, "function" == typeof requirejs && requirejs || void 0, {
    force_type: "factory"
});