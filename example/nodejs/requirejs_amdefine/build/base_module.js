/* Generated by Brace_UMD 0.4.3 */
!function(e, i, o, r, n) {
    var t, f, s, d, c, u = {
        e: e,
        requirejs: r,
        define: o,
        o: t || i && i.exports && i.filename || void 0,
        i: f || i && i.exports && i.require("path").dirname(i.filename) || void 0,
        n: {},
        r: {
            requirejs: !0,
            define: !0,
            require: !0,
            factory: !0
        },
        t: [ "config", "nextTick", "version", "jsExtRegExp", "isBrowser", "s", "toUrl", "undef", "defined", "specified", "onError", "createNode", "load", "exec" ],
        d: [ "amd", "require" ],
        s: function() {
            if (u.f && !u.define) try {
                u.define = u.f.require("amdefine")(u.f);
                for (var e in u.define) u.s[e] = u.define[e];
            } catch (e) {
                console.log(e.message);
            }
            var i = u.define || u.factory;
            i == u.define ? console.log("Using proxied amdefine definition.") : console.log("Using factory proxied from amdefine call."), 
            i.apply(i.prototype, arguments);
        },
        c: function() {
            if (u.f && !u.requirejs) try {
                u.requirejs = u.f.require("requirejs");
                for (var e in u.requirejs) u.c[e] = u.requirejs[e];
            } catch (e) {
                console.log(e.message);
            }
            console.log("Using proxied requirejs method.");
            var i = u.requirejs || u.factory;
            i.apply(i.prototype, arguments);
        }
    };
    u.factory = u.e && function(e, i, o, r) {
        if (e && e.constructor === Array && this.f) {
            var n = e, f = dependency;
            r = r, o = o, dependency = n, e = t || "";
        }
        "string" != typeof e ? console.log("The factory Object is being used but the module does not supply an id parameter. Skipping loading of the module.") : i.every(function(i) {
            return i in this.e || !!console.log("The dependency", i, "is not loaded into the factory. Skipping loading of the module", e);
        }, this) && (this.e[e] = o.apply(o.prototype, i.map(function(e, i) {
            return this.e[e];
        }, this)));
    }.bind(u);
    for (var a in u.d) u.s.__defineGetter__(u.d[a], function(e) {
        if (u.f && !u.define) try {
            u.define = u.f.require("amdefine")(u.f);
            for (var i in u.define) delete this[i], this[i] = u.define[i];
            return console.log("Using proxied amdefine method."), u.define[e];
        } catch (e) {
            return console.log(e.message);
        }
    }.bind(null, u.d[a]));
    for (var a in u.t) u.c.__defineGetter__(u.t[a], function(e) {
        if (u.f && !u.requirejs) try {
            u.requirejs = u.f.require("requirejs");
            for (var i in u.requirejs) delete this[i], this[i] = u.requirejs[i];
            return console.log("Using proxied requirejs method."), u.requirejs[i];
        } catch (e) {
            return console.log(e.message);
        }
    }.bind(null, u.t[a]));
    u.n.force_type && (u.n.force_type in u.r ? u[u.n.force_type] ? (console.log("Forcing use of the definition type", u.n.force_type), 
    u.requirejs = u.require = u.define = u.factory = u[u.n.force_type]) : console.log("The forced type", u.n.force_type, "is not available.") : console.log("The forced type", u.n.force_type, "specified as an option is not supported by Brace UMD. Supported types are", Object.keys(u.r))), 
    f = f || u.i, t = t || u.o, d = u.define || u.s, c = u.requirejs || u.c, s = u.f && u.f.require || c;
    d("second_module", [], function() {
        var e = "second_module";
        console.log(e + " has initialized.");
        var i = {};
        i.id = e;
        return i;
    });
    d("base_module", [ "second_module" ], function(e) {
        var i = "base_module";
        console.log(i + " has initialized.");
        var o = {};
        o.id = i;
        o[e.id] = e;
        return o;
    });
}(this, "object" == typeof module && module || void 0, "function" == typeof define && define || void 0, "function" == typeof requirejs && requirejs || void 0);