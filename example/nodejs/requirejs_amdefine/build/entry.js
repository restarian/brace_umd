/* Generated by Brace_UMD 0.4.0 */
!function(e, o, i, r, n) {
    var t, d, f, s, c, u = {
        e: e,
        requirejs: r,
        define: i,
        o: t || o && o.exports && o.filename || void 0,
        i: d || o && o.exports && o.require("path").dirname(o.filename) || void 0,
        n: {},
        r: {
            requirejs: !0,
            define: !0,
            require: !0,
            factory: !0
        },
        t: [ "config", "nextTick", "version", "jsExtRegExp", "isBrowser", "s", "toUrl", "undef", "defined", "specified", "onError", "createNode", "load", "exec" ],
        d: [ "amd", "require" ],
        s: function() {
            if (u.f && !u.define) try {
                u.define = u.f.require("amdefine")(u.f);
                for (var e in u.define) u.s[e] = u.define[e];
            } catch (e) {
                console.log(e.message);
            }
            var o = u.define || u.factory;
            o == u.define ? console.log("Using proxied amdefine definition.") : console.log("Using factory proxied from amdefine call."), 
            o.apply(o.prototype, arguments);
        },
        c: function() {
            if (u.f && !u.requirejs) try {
                u.requirejs = u.f.require("requirejs");
                for (var e in u.requirejs) u.c[e] = u.requirejs[e];
            } catch (e) {
                console.log(e.message);
            }
            console.log("Using proxied requirejs method.");
            var o = u.requirejs || u.factory;
            o.apply(o.prototype, arguments);
        }
    };
    u.factory = u.e && function(e, o, i, r) {
        if (e && e.constructor === Array && this.f) {
            var n = e, d = dependency;
            r = r, i = i, dependency = n, e = t || "";
        }
        "string" != typeof e ? console.log("The factory Object is being used but the module does not supply an id parameter. Skipping loading of the module.") : o.every(function(o) {
            return o in this.e || !!console.log("The dependency", o, "is not loaded into the factory. Skipping loading of the module", e);
        }, this) && (this.e[e] = i.apply(i.prototype, o.map(function(e, o) {
            return this.e[e];
        }, this)));
    }.bind(u);
    for (var l in u.d) u.s.__defineGetter__(u.d[l], function(e) {
        if (u.f && !u.define) try {
            u.define = u.f.require("amdefine")(u.f);
            for (var o in u.define) delete this[o], this[o] = u.define[o];
            return console.log("Using proxied amdefine method."), u.define[e];
        } catch (e) {
            return console.log(e.message);
        }
    }.bind(null, u.d[l]));
    for (var l in u.t) u.c.__defineGetter__(u.t[l], function(e) {
        if (u.f && !u.requirejs) try {
            u.requirejs = u.f.require("requirejs");
            for (var o in u.requirejs) delete this[o], this[o] = u.requirejs[o];
            return console.log("Using proxied requirejs method."), u.requirejs[o];
        } catch (e) {
            return console.log(e.message);
        }
    }.bind(null, u.t[l]));
    u.n.force_type && (u.n.force_type in u.r ? u[u.n.force_type] ? (console.log("Forcing use of the definition type", u.n.force_type), 
    u.requirejs = u.require = u.define = u.factory = u[u.n.force_type]) : console.log("The forced type", u.n.force_type, "is not available.") : console.log("The forced type", u.n.force_type, "specified as an option is not supported by Brace UMD. Supported types are", Object.keys(u.r))), 
    d = d || u.i, t = t || u.o, s = u.define || u.s, c = u.requirejs || u.c, f = u.f && u.f.require || c;
    s("module_one", [], function() {
        var e = "module_one";
        console.log(e + " has initialized.");
        var o = {};
        o.id = e;
        return o;
    });
    s("second_module", [], function() {
        var e = "second_module";
        console.log(e + " has initialized.");
        var o = {};
        o.id = e;
        return o;
    });
    var c = f("requirejs");
    c.config({
        baseUrl: d,
        nodeRequire: f
    });
    c([ "module_one", "second_module" ], function(e, o) {
        var i = "entry";
        console.log(i + " has initialized.");
        var r = {};
        r.id = i;
        r[e.id] = e;
        r[o.id] = o;
        console.log(e, o);
        return r;
    });
    s("entry", function() {});
}(this, "object" == typeof module && module || void 0, "function" == typeof define && define || void 0, "function" == typeof requirejs && requirejs || void 0);