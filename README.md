# Brace UMD
### Synopsis

#### A unified module definition script to support Requirejs and AMDefine definitions while working seamlessly with the requirejs optimizer and a native global Object.

[![Build status](https://ci.appveyor.com/api/projects/status/j9w4v3romfw971y9/branch/master?svg=true)](https://ci.appveyor.com/project/restarian/brace-umd/branch/master) [![Build Status](https://travis-ci.org/restarian/brace_umd.svg?branch=master)](https://travis-ci.org/restarian/brace_umd) [![Downloads](https://img.shields.io/npm/dm/brace_umd.svg?svg=true)](https://npmjs.org/package/brace_umd)

..part of the [Brace suite](https://github.com/restarian/restarian/blob/master/brace/README.md)
![Brace](https://raw.githubusercontent.com/restarian/restarian/master/brace/doc/image/brace_logo_small.png)

------

### Document pages
* [(Re)building the source](https://github.com/restarian/brace_umd/blob/master/doc/build.md)
* [Exported module data ](https://github.com/restarian/brace_umd/blob/master/doc/exported_data.md)
* [License information](https://github.com/restarian/brace_umd/blob/master/doc/license.md)
* [Using Brace UMD with the Requirejs optimizer](https://github.com/restarian/brace_umd/blob/master/doc/optimizer.md)
* [Available option data](https://github.com/restarian/brace_umd/blob/master/doc/options.md)
* [How to use option data](https://github.com/restarian/brace_umd/blob/master/doc/passing_option_data.md)
* [Specifications](https://github.com/restarian/brace_umd/blob/master/doc/specification.md)
* [Todo](https://github.com/restarian/brace_umd/blob/master/doc/todo.md)

----

[![Bash on Windows](https://raw.githubusercontent.com/restarian/brace_umd/master/doc/image/ubuntu_windows_logo.png)](https://github.com/Microsoft/BashOnWindows)

**Author: Robert Steckroth, Bust0ut**

**License: MIT**

**Bonuses:**
* Adds zero new namespaces
* Provides automatic anonymous module creation for amdefine modules
* Provides a way to switch between definition types without altering source code
* Allows for almost total minification of wrapped source code using most of the uglify-js options
* Expands to incorporate other definitions
* Well commented, professionally engineered and thoroughly documented code
* Vast and deep unit tests on Windows 10 and Ubuntu 16

**Caveats:**
  * Requires nodejs version 5 or greater
  * An id string must be used in order to have native global Object support in environments other than nodejs. Otherwise, it can be omitted to work with the other definitions. However, this is not an issue if the module is ran through the requirejs optimizer (which adds ids to all modules).

**Brace UMD is better than other more simple module definition wrappers** by enabling uglifyjs functionality and option data. This allows for use of the requirejs optimizer regardless of what definitions are contained within the module. An AMD library is only loaded and used if the correlated call to it is contained within the script. E.g. The *amdefine* module is not loaded unless a call to *define* is inside of the script. Otherwise, a proxy function is supplied for the supported definitions.

**Note**: it is acceptable to use mangle and mangle properties with the UMD source and in the requirejs optimizing process. This is done by storing the build config options used and then passing them back into uglify-js via the r.js build config file (see [using with requirejs](https://github.com/restarian/brace_umd/blob/master/doc/optimizer.md), for more information.

**Below is the UMD script. The following code will work in nodejs or the browser with and can use any of the supported definitions:**

```javascript
/* Generated by Brace_UMD 0.6.0 */
!function(e, i, o, t) {
    var __filename, __dirname, define, requirejs, require, n = {
        e: "object" == typeof module,
        i: !1,
        filename: "",
        factory: function(i, o, t, s) {
            i && i.constructor === Array && n.e && (s = t, t = o, o = i, i = n.filename), "string" != typeof i ? console.log("The factory Object is being used but the module does not supply an id parameter. Skipping loading of the module.") : o.every(function(o) {
                return o in e || !!console.log("The dependency", o, "is not loaded into the factory. Skipping loading of the module", i);
            }) && (e[i] = t.apply(t.prototype, o.map(function(e, i) {
                return this[e];
            }, e)));
        },
        requirejs: o,
        define: i,
        o: "object" == typeof t && t || {},
        t: function() {
            var e = {
                define: !this.o.auto_anonymous && this.define || this.n.bind(this),
                requirejs: this.requirejs || this.s.bind(this),
                require: this.requirejs || this.e && module.require || this.factory,
                factory: this.factory
            }, i = this.o.force_type && this.o.force_type.toString() || "";
            i && (!i in e ? console.log("The forced type", i, "specified as an option is not supported by Brace UMD. Supported types are", Object.keys(e)) : (console.log("Forcing use of the definition type", i), 
            e.requirejs = e.require = e.define = e.factory = e[i])), define = e.define, requirejs = e.requirejs, 
            require = e.require;
        },
        r: [ "config", "nextTick", "version", "jsExtRegExp", "isBrowser", "s", "toUrl", "undef", "defined", "specified", "onError", "createNode", "load", "exec" ],
        d: [ "amd", "require" ],
        n: function() {
            if (n.e && !this.define) try {
                this.define = module.require("amdefine")(module);
                for (var e in this.define) this.n[e] = this.define[e];
            } catch (e) {
                console.log("Unable to find amdefine module.", e.message);
            }
            var i = this.define || this.factory.bind(this);
            i == this.define ? console.log("Using proxied amdefine definition.") : console.log("Using factory proxied from amdefine call."), 
            i == this.define && this.o.auto_anonymous ? !0 !== this.i && arguments.length > 2 ? this.i = arguments[0] : arguments.length <= 2 && (this.i = !0) : (this.n = i, 
            this.t()), i.apply(i.prototype, arguments);
        },
        s: function() {
            if (commonjs_available && !this.requirejs) try {
                this.requirejs = this.a.require("requirejs");
                for (var e in this.requirejs) this.s[e] = this.requirejs[e];
            } catch (e) {
                console.log("Unable to find requirejs module.", e.message);
            }
            console.log("Using proxied requirejs method.");
            var i = this.requirejs || this.factory;
            this.s = i, i.apply(i.prototype, arguments);
        }
    };
    for (var s in n.d) n.n.__defineGetter__(n.d[s], function(e) {
        if (commonjs_available && !n.define) try {
            n.define = module.require("amdefine")(module);
            for (var i in n.define) delete this[i], this[i] = n.define[i];
            return console.log("Using proxied amdefine method."), n.define[e];
        } catch (e) {
            return console.log("Unable to find amdefine module.", e.message);
        }
    }.bind(null, n.d[s]));
    for (var s in n.r) n.s.__defineGetter__(n.r[s], function(e) {
        if (commonjs_available && !n.requirejs) try {
            n.requirejs = module.require("requirejs");
            for (var i in n.requirejs) delete this[i], this[i] = n.requirejs[i];
            return console.log("Using proxied requirejs method."), n.requirejs[i];
        } catch (e) {
            return console.log("Unable to find requirejs module.", e.message);
        }
    }.bind(null, n.r[s]));
    __filename = n.e && module.filename || "", __dirname = n.e && module.require("path").dirname(__filename) || "",
	n.t(), n.e && (n.filename = module.require("path").basename(__filename))

	// Add module definitions here ----------------

 
	// --------------------------------------------

    n.i.length && define([ n.i ], function(e) {
        return e;
    });
}(this, "function" == typeof define && define || void 0, "function" == typeof requirejs && requirejs || void 0, {});
```
