# Brace UMD
### Module synopsis

#### A unified module definition script to support modules written with Requirejs and AMDefine syntax while working seamlessly with the r.js optimizer and the native global Object.

[![Build status](https://ci.appveyor.com/api/projects/status/j9w4v3romfw971y9/branch/master?svg=true)](https://ci.appveyor.com/project/restarian/brace-umd/branch/master) [![Build Status](https://travis-ci.org/restarian/brace_umd.svg?branch=master)](https://travis-ci.org/restarian/brace_umd) [![Downloads](https://img.shields.io/npm/dm/brace_umd.svg?svg=true)](https://npmjs.org/package/brace_umd)

..part of the [Brace suite](https://github.com/restarian/restarian/blob/master/brace/README.md)

------

### Document pages
* [(Re)building the source](https://github.com/restarian/brace_umd/blob/master/doc/build.md)
* [Exported build data](https://github.com/restarian/brace_umd/blob/master/doc/export.md)
* [License information](https://github.com/restarian/brace_umd/blob/master/doc/license.md)
* [Using Brace UMD with the Requirejs optimizer](https://github.com/restarian/brace_umd/blob/master/doc/optimizer.md)
* [Specifications](https://github.com/restarian/brace_umd/blob/master/doc/specification.md)
* [Todo](https://github.com/restarian/brace_umd/blob/master/doc/todo.md)

----

[![Bash on Windows](https://raw.githubusercontent.com/restarian/brace_umd/master/doc/image/ubuntu_windows_logo.png)](https://github.com/Microsoft/BashOnWindows)

**Author: Robert Steckroth, Bust0ut**

**License: MIT**

**Bonuses:**
* well commented, professional code
* thoroughly documented
* vast and deep unit tests on Windows 10 and Ubuntu 16.04

**Caveats:**
  * Requires nodejs version 5 or greater
  * An id string must be used in order to have native global Object support in environments other than nodejs. Otherwise, it can be omitted to supply only RequireJs, AMDefine and r.js support.

Brace UMD is better than other more simple module definition scripts by enabling uglifyjs functionality. This allows for use of the r.js optimizer regardless of what definitions are contained within the module. The module definition type if only loaded and used if the correlated call to it is contained within the script. E.g. The amdefine module is not loaded unless a call to define is inside of the script. Otherwise, a proxy function is supplied for the supported types. 
Note: it is acceptable to use mangle and mangle properties with the umd source and in the r.js optimizing process. This is done through the use of build config which can be passed to the r.js build config file (see [use with r.js](https://github.com/restarian/brace_umd/blob/master/doc/optimizer.md), for more information.

**Below are some ways to use the UMD. The following code works in nodejs or the browser:**

```javascript
/* Generated by Brace_UMD 0.4.0 */
!function(e, o, i, n, r) {
    var __filename, __dirname, require, define, requirejs, t = {
        e: e,
        requirejs: n,
        define: i,
        o: __filename || o && o.exports && o.filename || void 0,
        i: __dirname || o && o.exports && o.require('path').dirname(o.filename) || void 0,
        n: {},
        r: {
            requirejs: !0,
            define: !0,
            require: !0,
            factory: !0
        },
        t: [ 'config', 'nextTick', 'version', 'jsExtRegExp', 'isBrowser', 's', 'toUrl', 'undef', 'defined', 'specified', 'onError', 'createNode', 'load', 'exec' ],
        d: [ 'amd', 'require' ],
        s: function() {
            if (t.f && !t.define) try {
                t.define = t.f.require('amdefine')(t.f);
                for (var e in t.define) t.s[e] = t.define[e];
            } catch (e) {
                console.log(e.message);
            }
            var o = t.define || t.factory;
            o == t.define ? console.log('Using proxied amdefine definition.') : console.log('Using factory proxied from amdefine call.'), 
            o.apply(o.prototype, arguments);
        },
        c: function() {
            if (t.f && !t.requirejs) try {
                t.requirejs = t.f.require('requirejs');
                for (var e in t.requirejs) t.c[e] = t.requirejs[e];
            } catch (e) {
                console.log(e.message);
            }
            console.log('Using proxied requirejs method.');
            var o = t.requirejs || t.factory;
            o.apply(o.prototype, arguments);
        }
    };
    t.factory = t.e && function(e, o, i, n) {
        if (e && e.constructor === Array && this.f) {
            var r = e, t = dependency;
            n = n, i = i, dependency = r, e = __filename || '';
        }
        'string' != typeof e ? console.log('The factory Object is being used but the module does not supply an id parameter. Skipping loading of the module.') : o.every(function(o) {
            return o in this.e || !!console.log('The dependency', o, 'is not loaded into the factory. Skipping loading of the module', e);
        }, this) && (this.e[e] = i.apply(i.prototype, o.map(function(e, o) {
            return this.e[e];
        }, this)));
    }.bind(t);
    for (var d in t.d) t.s.__defineGetter__(t.d[d], function(e) {
        if (t.f && !t.define) try {
            t.define = t.f.require('amdefine')(t.f);
            for (var o in t.define) delete this[o], this[o] = t.define[o];
            return console.log('Using proxied amdefine method.'), t.define[e];
        } catch (e) {
            return console.log(e.message);
        }
    }.bind(null, t.d[d]));
    for (var d in t.t) t.c.__defineGetter__(t.t[d], function(e) {
        if (t.f && !t.requirejs) try {
            t.requirejs = t.f.require('requirejs');
            for (var o in t.requirejs) delete this[o], this[o] = t.requirejs[o];
            return console.log('Using proxied requirejs method.'), t.requirejs[o];
        } catch (e) {
            return console.log(e.message);
        }
    }.bind(null, t.t[d]));
    t.n.force_type && (t.n.force_type in t.r ? t[t.n.force_type] ? (console.log('Forcing use of the definition type', t.n.force_type), 
    t.requirejs = t.require = t.define = t.factory = t[t.n.force_type]) : console.log('The forced type', t.n.force_type, 'is not available.') : console.log('The forced type', t.n.force_type, 'specified as an option is not supported by Brace UMD. Supported types are', Object.keys(t.r))), 
    __dirname = __dirname || t.i, __filename = __filename || t.o, define = t.define || t.s, 
    requirejs = t.requirejs || t.c, require = t.f && t.f.require || requirejs;

	// modules can be defined here using: define, require or requirejs.

}(this, 'object' == typeof module && module || void 0, 'function' == typeof define && define || void 0, 'function' == typeof requirejs && requirejs || void 0);
```
