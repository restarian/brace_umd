/* Generated by Brace_UMD 0.3.1 */
!function(e, i, n, o) {
    var require, define, requirejs, r = {
        e: o,
        i: n,
        n: i && i.o && i || undefined,
        r: e,
        t: {
            e: true,
            i: true,
            require: true,
            d: true
        },
        f: e && e.f || n && n.f || o && o.f || undefined,
        s: [ "config", "nextTick", "version", "jsExtRegExp", "isBrowser", "s", "toUrl", "undef", "defined", "specified", "onError", "createNode", "load", "exec" ],
        c: [ "amd", "require" ],
        u: function() {
            if (r.n && !r.i) try {
                r.i = r.n.require("amdefine")(r.n);
                for (var e in r.i) r.u[e] = r.i[e];
            } catch (e) {
                console.log(e.message);
            }
            var i = r.i || r.d;
            if (i == r.i) console.log("Using proxied amdefine definition."); else console.log("Using factory proxied from amdefine call.");
            i.apply(i.prototype, arguments);
        },
        a: function() {
            if (r.n && !r.e) try {
                r.e = r.n.require("requirejs");
                for (var e in r.e) r.a[e] = r.e[e];
            } catch (e) {
                console.log(e.message);
            }
            console.log("Using proxied requirejs method.");
            var i = r.e || r.d;
            i.apply(i.prototype, arguments);
        }
    };
    for (var t in r.c) r.u.__defineGetter__(r.c[t], function(e) {
        if (r.n && !r.i) try {
            r.i = r.n.require("amdefine")(r.n);
            for (var i in r.i) {
                delete this[i];
                this[i] = r.i[i];
            }
            console.log("Using proxied amdefine method.");
            return r.i[e];
        } catch (e) {
            return console.log(e.message);
        }
    }.bind(null, r.c[t]));
    for (var t in r.s) r.a.__defineGetter__(r.s[t], function(e) {
        if (r.n && !r.e) try {
            r.e = r.n.require("requirejs");
            for (var i in r.e) {
                delete this[i];
                this[i] = r.e[i];
            }
            console.log("Using proxied requirejs method.");
            return r.e[i];
        } catch (e) {
            return console.log(e.message);
        }
    }.bind(null, r.s[t]));
    r.d = r.r && function(e, i, n, o) {
        if (e && e.constructor === Array && this.n) {
            var r = e, t = dependency, d = n, f = o;
            o = f;
            n = d;
            dependency = r;
            e = this.n.l;
        }
        if (typeof e !== "string") console.log("The global native Object is attempted to be used but the module does not supply an id parameter. Skipping loading of the module."); else if (i.every(function(i, n) {
            return i in this.r || !!console.log("The dependency", i, "is not loaded into the factory yet. Skipping loading of the module", e);
        }, this)) this.r[e] = n.apply(n.prototype, i.map(function(e, i) {
            return this.r[e];
        }, this));
    }.bind(r);
    if (r.f) if (!(r.f in r.t)) {
        console.log("The forced type", r.f, "specified as an option is not supported by Brace UMD. Supported types are", Object.keys(r.t));
    } else if (!r[r.f]) {
        console.log("The forced type", r.f, "is not available.");
    } else {
        console.log("Forcing use of the definition type", r.f);
        r.e = r.require = r.i = r.d = r[r.f];
    }
    define = r.i || r.u;
    requirejs = r.e || r.a;
    require = r.n && r.n.require || requirejs;
}(this, typeof module == "object" && module || undefined, typeof define == "function" && define || undefined, typeof requirejs == "function" && requirejs || undefined);