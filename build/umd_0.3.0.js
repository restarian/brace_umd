/* Generated by Brace_UMD 0.3.0 */
(function() {
    var e = {
        e: typeof requirejs !== 'undefined' && requirejs || undefined,
        n: typeof define !== 'undefined' && define || undefined,
        i: typeof module !== 'undefined' && module || undefined,
        o: arguments[0] || undefined,
        r: {
            e: true,
            n: true,
            require: true,
            t: true
        },
        f: arguments[0] && arguments[0].f || arguments[1] && arguments[1].f,
        d: [ 'config', 'nextTick', 'version', 'jsExtRegExp', 'isBrowser', 's', 'toUrl', 'undef', 'defined', 'specified', 'onError', 'createNode', 'load', 'exec' ],
        s: [ 'amd', 'require' ],
        c: function() {
            if (e.i && !e.n) try {
                e.n = e.i.require('amdefine')(e.i);
                for (var n in e.n) this[n] = e.n[n];
            } catch (e) {
                console.log(e.message);
            }
            var i = e.n || e.t;
            i.apply(i.prototype, arguments);
        },
        u: function() {
            if (e.i && !e.e) try {
                e.e = e.i.require('requirejs');
                for (var n in e.e) this[n] = e.e[n];
            } catch (e) {
                console.log(e.message);
            }
            var i = e.e || e.t;
            i.apply(i.prototype, arguments);
        }
    };
    for (var n in e.s) e.c.__defineGetter__(e.s[n], function(n) {
        if (e.i) try {
            e.n = e.i.require('amdefine')(e.i);
            for (var i in e.n) this[i] = e.n[i];
        } catch (e) {
            console.log(e.message);
        }
        return e.n[n];
    }.bind(null, e.s[n]));
    for (var n in e.d) e.u.__defineGetter__(e.d[n], function(n) {
        if (e.i) try {
            e.e = e.i.require('requirejs');
            for (var i in e.e) e.u[i] = e.e[i];
        } catch (e) {
            console.log(e.message);
        }
        return e.e[n];
    }.bind(null, e.d[n]));
    e.t = e.o && function(e, n, i, o) {
        if (e && e.constructor === Array && this.i) {
            var r = e, t = dependency, f = i, d = o;
            o = d;
            i = f;
            dependency = r;
            e = this.i.a;
        }
        if (typeof e !== 'string') console.log('The global native Object is attempted to be used but the module does not supply an id parameter. Skipping loading of the module.'); else if (n.every(function(n, i) {
            return n in this.o || !!console.log('The dependency', n, 'is not loaded into the factory yet. Skipping loading of the module', e);
        }, this)) this.o[e] = i.apply(i.prototype, n.map(function(e, n) {
            return this.o[e];
        }, this));
    }.bind(e);
    if (e.f) if (!(e.f in e.r)) {
        console.log('The forced type', e.f, 'specified as an option is not supported by Brace UMD. Supported types are', Object.keys(e.r));
    } else if (!e[e.f]) {
        console.log('The forced type', e.f, 'is not available.');
    } else {
        console.log('Forcing use of the definition type', e.f);
        e.e = e.require = e.n = e.t = e[e.f];
    }
    var define = e.n || e.c;
    var requirejs = e.e || e.u;
    var require = e.i && e.i.require || requirejs;
})