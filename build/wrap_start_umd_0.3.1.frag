/* Generated by Brace_UMD 0.3.1 */
!function(e, o, i, n, r) {
    r = r || {};
    var require, define, requirejs, t = {
        requirejs: n,
        define: i,
        e: o && o.o && o || void 0,
        i: o && o.o || e,
        n: "requirejs,define,require,factory,",
        force_type: r.force_type,
        r: [ "config", "nextTick", "version", "jsExtRegExp", "isBrowser", "s", "toUrl", "undef", "defined", "specified", "onError", "createNode", "load", "exec" ],
        t: [ "amd", "require" ],
        s: function() {
            if (t.e && !t.define) try {
                t.define = t.e.require("amdefine")(t.e);
                for (var e in t.define) t.s[e] = t.define[e];
            } catch (e) {
                console.log(e.message);
            }
            var o = t.define || t.factory;
            o == t.define ? console.log("Using proxied amdefine definition.") : console.log("Using factory proxied from amdefine call."), 
            o.apply(o.prototype, arguments);
        },
        d: function() {
            if (t.e && !t.requirejs) try {
                t.requirejs = t.e.require("requirejs");
                for (var e in t.requirejs) t.d[e] = t.requirejs[e];
            } catch (e) {
                console.log(e.message);
            }
            console.log("Using proxied requirejs method.");
            var o = t.requirejs || t.factory;
            o.apply(o.prototype, arguments);
        }
    };
    for (var s in t.t) t.s.__defineGetter__(t.t[s], function(e) {
        if (t.e && !t.define) try {
            t.define = t.e.require("amdefine")(t.e);
            for (var o in t.define) delete this[o], this[o] = t.define[o];
            return console.log("Using proxied amdefine method."), t.define[e];
        } catch (e) {
            return console.log(e.message);
        }
    }.bind(null, t.t[s]));
    for (var s in t.r) t.d.__defineGetter__(t.r[s], function(e) {
        if (t.e && !t.requirejs) try {
            t.requirejs = t.e.require("requirejs");
            for (var o in t.requirejs) delete this[o], this[o] = t.requirejs[o];
            return console.log("Using proxied requirejs method."), t.requirejs[o];
        } catch (e) {
            return console.log(e.message);
        }
    }.bind(null, t.r[s]));
    t.factory = t.i && function(e, o, i, n) {
        if (e && e.constructor === Array && this.e) {
            var r = e, t = dependency;
            n = n, i = i, dependency = r, e = this.e.f || "";
        }
        "string" != typeof e ? console.log("The factory Object is being used but the module does not supply an id parameter. Skipping loading of the module.") : o.every(function(o) {
            return o in this.i || !!console.log("The dependency", o, "is not loaded into the factory. Skipping loading of the module", e);
        }, this) && (this.i[e] = i.apply(i.prototype, o.map(function(e, o) {
            return this.i[e];
        }, this)));
    }.bind(t), t.force_type && (new RegExp(t.force_type + ",+").test(t.n) ? t[t.force_type] ? (console.log("Forcing use of the definition type", t.force_type), 
    t.requirejs = t.require = t.define = t.factory = t[t.force_type]) : console.log("The forced type", t.force_type, "is not available.") : console.log("The forced type", t.force_type, "specified as an option is not supported by Brace UMD. Supported types are", t.n.substr(0, t.n.length - 2))), 
    define = t.define || t.s, requirejs = t.requirejs || t.d, require = t.e && t.e.require || requirejs;
;