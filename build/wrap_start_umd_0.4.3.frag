/* Generated by Brace_UMD 0.4.3 */
!function(e, o, i, n, r) {
    var __filename, __dirname, require, define, requirejs, t = {
        e: o,
        o: e,
        requirejs: n,
        define: i,
        i: __filename || o && o.exports && o.filename || void 0,
        n: __dirname || o && o.exports && o.require('path').dirname(o.filename) || void 0,
        r: r,
        t: {
            requirejs: !0,
            define: !0,
            require: !0,
            factory: !0
        },
        d: [ 'config', 'nextTick', 'version', 'jsExtRegExp', 'isBrowser', 's', 'toUrl', 'undef', 'defined', 'specified', 'onError', 'createNode', 'load', 'exec' ],
        s: [ 'amd', 'require' ],
        f: function() {
            if (t.e && !t.define) try {
                t.define = t.e.require('amdefine')(t.e);
                for (var e in t.define) t.f[e] = t.define[e];
            } catch (e) {
                console.log('Unable to find amdefine module.', e.message);
            }
            var o = t.define || t.factory;
            o == t.define ? console.log('Using proxied amdefine definition.') : console.log('Using factory proxied from amdefine call.'), 
            o.apply(o.prototype, arguments);
        },
        c: function() {
            if (t.e && !t.requirejs) try {
                t.requirejs = t.e.require('requirejs');
                for (var e in t.requirejs) t.c[e] = t.requirejs[e];
            } catch (e) {
                console.log('Unable to find requirejs module.', e.message);
            }
            console.log('Using proxied requirejs method.');
            var o = t.requirejs || t.factory;
            o.apply(o.prototype, arguments);
        }
    };
    t.factory = t.o && function(e, o, i, n) {
        if (e && e.constructor === Array && this.e) {
            var r = e, t = dependency;
            n = n, i = i, dependency = r, e = __filename || '';
        }
        'string' != typeof e ? console.log('The factory Object is being used but the module does not supply an id parameter. Skipping loading of the module.') : o.every(function(o) {
            return o in this.o || !!console.log('The dependency', o, 'is not loaded into the factory. Skipping loading of the module', e);
        }, this) && (this.o[e] = i.apply(i.prototype, o.map(function(e, o) {
            return this.o[e];
        }, this)));
    }.bind(t);
    for (var d in t.s) t.f.__defineGetter__(t.s[d], function(e) {
        if (t.e && !t.define) try {
            t.define = t.e.require('amdefine')(t.e);
            for (var o in t.define) delete this[o], this[o] = t.define[o];
            return console.log('Using proxied amdefine method.'), t.define[e];
        } catch (e) {
            return console.log('Unable to find amdefine module.', e.message);
        }
    }.bind(null, t.s[d]));
    for (var d in t.d) t.c.__defineGetter__(t.d[d], function(e) {
        if (t.e && !t.requirejs) try {
            t.requirejs = t.e.require('requirejs');
            for (var o in t.requirejs) delete this[o], this[o] = t.requirejs[o];
            return console.log('Using proxied requirejs method.'), t.requirejs[o];
        } catch (e) {
            return console.log('Unable to find requirejs module.', e.message);
        }
    }.bind(null, t.d[d]));
    t.r.force_type && (t.r.force_type in t.t ? t[t.r.force_type] ? (console.log('Forcing use of the definition type', t.r.force_type), 
    t.requirejs = t.require = t.define = t.factory = t[t.r.force_type]) : console.log('The forced type', t.r.force_type, 'is not available.') : console.log('The forced type', t.r.force_type, 'specified as an option is not supported by Brace UMD. Supported types are', Object.keys(t.t))), 
    __dirname = __dirname || t.n, __filename = __filename || t.i, define = t.define || t.f, 
    requirejs = t.requirejs || t.c, require = t.e && t.e.require || requirejs;
;